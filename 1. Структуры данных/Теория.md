# Структуры данных: Stack, Queue, Deque, List, Hash table

### Стек (Stack)
- **Структура данных**, работающая по принципу "последний вошел, первый вышел" (LIFO - Last In, First Out).
- Поддерживает операции **push** (добавление элемента в вершину стека) и **pop** (удаление и возврат элемента из вершины стека).
- Также может поддерживать операцию **peek** (получение элемента из вершины стека без его удаления).
- Используется, например, при реализации функций вызова (call stack) в программировании или при обратной польской записи для вычисления арифметических выражений.

### Очередь (Queue)
- **Структура данных**, работающая по принципу "первый вошел, первый вышел" (FIFO - First In, First Out).
- Поддерживает операции **enqueue** (добавление элемента в конец очереди) и **dequeue** (удаление и возврат элемента из начала очереди).
- Также может поддерживать операцию **peek** (получение элемента из начала очереди без его удаления).
- Используется, например, для управления задачами в очереди, моделирования обслуживания запросов или управления ресурсами в параллельном программировании.

### Двусторонняя очередь (Deque)
- **Структура данных**, которая представляет собой двустороннюю очередь, то есть поддерживает добавление и удаление элементов как с начала, так и с конца.
- Поддерживает операции **appendleft** и **append** для добавления элементов в начало и конец, а также операции **popleft** и **pop** для удаления элементов с начала и конца соответственно.
- Используется, например, для реализации двусторонних алгоритмов обхода графов, работы с буферами или для реализации LRU кэшей.

### Список (List)
- Одна из базовых **структур данных**, представляющая собой упорядоченную последовательность элементов.
- Поддерживает операции добавления, удаления и доступа к элементам по индексу.
- В Python список представлен встроенным типом `list`.
- Используется для хранения и обработки коллекции элементов различных типов.

### Хеш-таблица (Hash table)
- **Структура данных**, которая реализует ассоциативный массив, связывая ключи с значениями.
- Использует функцию хеширования для преобразования ключей в индексы таблицы, что обеспечивает эффективный поиск, вставку и удаление элементов.
- В Python хеш-таблицы обычно реализованы в виде словарей (`dict`).
- Используется для реализации ассоциативных массивов, кэшей, множеств и других структур данных, где требуется быстрый доступ к данным по ключу.

# Типы данных

### str (строка)
- Строки используются для хранения текстовой информации.

### bytes (байт)
- Представляет последовательность байтов, используемых для работы с бинарными данными.

## bytearray (массив байтов)
- Изменяемая последовательность байтов.

### int (целое число)
- Используется для хранения целых чисел.

### float (вещественное число)
- Представляет числа с плавающей запятой.

### bool (логическое значение)
- Используется для хранения логических значений True или False.

### dict (словарь)
- Хранит коллекцию пар ключ-значение.

### list (список)
- Упорядоченная изменяемая коллекция элементов.

### tuple (кортеж)
- Упорядоченная неизменяемая коллекция элементов.

### set (множество)
- Неупорядоченная коллекция уникальных элементов.

# Изменяемые и Неизменяемые Типы Данных

### Неизменяемые
- `int`, `float`, `str`, `tuple`

### Изменяемые
- `list`, `dict`, `set`

# Алгоритмы сортировки: Пузырьком и вставками

### Сортировка пузырьком (Bubble Sort)
- Простой **алгоритм сортировки**, который многократно проходит по списку, сравнивая пары соседних элементов и меняя их местами, если они находятся в неправильном порядке.
- При каждом проходе самый большой элемент "всплывает" на правильное место.
- Алгоритм завершает работу, когда на очередном проходе не происходит ни одного обмена, что означает, что список уже отсортирован.
- Хотя сортировка пузырьком проста в реализации, она неэффективна для больших списков из-за своей квадратичной временной сложности.
```python
# Сортировка пузырьком
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]

# Пример использования сортировки пузырьком
arr = [64, 34, 25, 12, 22, 11, 90]
bubble_sort(arr)
print("Отсортированный массив:", arr)
```
### Сортировка вставками (Insertion Sort)
- **Алгоритм сортировки** строит отсортированную последовательность, добавляя по одному элементу из исходного списка на правильное место в уже отсортированной части списка.
- На каждом шаге алгоритм берет очередной элемент из неотсортированной части списка и вставляет его на правильное место в уже отсортированной части.
- Продолжает этот процесс до тех пор, пока все элементы не будут добавлены в отсортированную часть.
- В среднем и в худшем случае временная сложность сортировки вставками составляет $$O(n^2)$$ что делает его неэффективным для сортировки больших списков, но он может быть эффективен для небольших списков или списков, частично отсортированных. Каждый из этих алгоритмов имеет свои особенности и применения в зависимости от размера списка, его упорядоченности и других факторов.
```python
# Сортировка вставками
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i-1
        while j >=0 and key < arr[j]:
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = key

# Пример использования сортировки вставками
arr = [12, 11, 13, 5, 6]
insertion_sort(arr)
print("Отсортированный массив:", arr)
```

# Алгоритмы поиска: Линейный и бинарный

### Линейный поиск (Linear Search)
- Простой **алгоритм поиска**, который последовательно проверяет каждый элемент списка или массива на наличие искомого значения.
- Начиная с первого элемента, он сравнивает каждый элемент с искомым значением до тех пор, пока не найдет совпадение или не пройдет весь список.
- Если искомое значение не найдено, алгоритм возвращает специальное значение (например, -1) или указывает на отсутствие значения.
```python
# Линейный поиск
def linear_search(arr, x):
    for i in range(len(arr)):
        if arr[i] == x:
            return i
    return -1

# Пример использования линейного поиска
arr = [3, 4, 1, 7, 5]
x = 7
index = linear_search(arr, x)
print(f"Элемент найден на позиции: {index}" if index != -1 else "Элемент не найден")
```

### Бинарный поиск (Binary Search)
- Эффективный **алгоритм поиска**, работающий только для отсортированных списков или массивов.
- Начинает поиск с середины списка и сравнивает искомое значение с элементом в середине.
- Если значение совпадает, поиск завершается.
- Если значение меньше элемента в середине, поиск продолжается в левой половине списка.
- Если значение больше элемента в середине, поиск продолжается в правой половине списка.
- Повторяет этот процесс, сокращая размер области поиска вдвое на каждом шаге, пока не будет найдено совпадение или пока область поиска не станет пустой.
- Бинарный поиск имеет временную сложность $$O(\log n)$$ что делает его очень эффективным для больших отсортированных списков.
```python
# Бинарный поиск
def binary_search(arr, x):
    low = 0
    high = len(arr) - 1
    mid = 0

    while low <= high:
        mid = (high + low) // 2
        # Если x больше, игнорируем левую половину
        if arr[mid] < x:
            low = mid + 1
        # Если x меньше, игнорируем правую половину
        elif arr[mid] > x:
            high = mid - 1
        # Значит x присутствует в mid
        else:
            return mid
    # Если мы достигли сюда, элемента нет в массиве
    return -1

# Пример использования бинарного поиска
arr = [1, 3, 4, 5, 7]
x = 5
index = binary_search(arr, x)
print(f"Элемент найден на позиции: {index}" if index != -1 else "Элемент не найден")
```
Выбор между линейным и бинарным поиском зависит от различных факторов, таких как упорядоченность данных, размер списка и доступность сортировки. Если данные неотсортированы или изменяются часто, линейный поиск может быть более подходящим. Однако, если данные отсортированы и не меняются, бинарный поиск предпочтительнее из-за его высокой эффективности.

# Big O Notation: Сложность Операций Чтение/Запись

### Стек (Stack)
- Чтение или запись n-ного элемента из стека имеет сложность **O(n)**.
- Стек - это структура данных Last-In-First-Out (LIFO), где доступ к элементам осуществляется только с одного конца.

### Очередь (Queue)
- Чтение или запись n-ного элемента из очереди имеет сложность **O(n)**.
- Очередь - это структура данных First-In-First-Out (FIFO), где доступ к элементам осуществляется с разных концов.

### Дек (Deque)
- Чтение или запись n-ного элемента из дека имеет сложность **O(n)**.
- Дек поддерживает операции добавления и удаления элементов с обоих концов.

### Список (List)
- Для связанных списков чтение или запись n-ного элемента имеет сложность **O(n)**.
- Для списков на основе массивов доступ к элементу по индексу может иметь сложность **O(1)**.

### Хэш-таблица (Hash table)
- В среднем случае, сложность операции чтения или записи элемента в хэш-таблице **O(1)**.
- В худшем случае, при коллизиях, сложность может быть **O(n)**.

# Big O для операций чтение/запись

### dict (словарь)
- Чтение (по ключу): **O(1)**
- Запись (по ключу): **O(1)**
- Удаление (по ключу): **O(1)**

### list (список)
- Чтение (по индексу): **O(1)**
- Запись (по индексу): **O(1)**
- Вставка/Удаление: **O(n)**

### tuple (кортеж)
- Чтение (по индексу): **O(1)**
- Кортежи не поддерживают операции вставки и удаления.

### set (множество)
- Чтение (по значению): **O(1)**
- Вставка/Удаление: **O(1)** в среднем

# List / Dict / Set Comprehensions

### List Comprehension
- Создание списка квадратов чисел: `[x**2 for x in range(10)]`
- Создание списка четных чисел: `[x for x in range(10) if x % 2 == 0]`

### Dict Comprehension
- Создание словаря с квадратами чисел: `{x: x**2 for x in range(10)}`

### Set Comprehension
- Создание множества квадратов чисел: `{x**2 for x in range(10)}`

# Хэшируемые Типы Данных

`Хэшируемые типы данных` в Python - это такие типы, которые имеют неизменяемое `хэш-значение`. Это означает, что они могут быть использованы в качестве ключей в словарях (`dict`) и элементов в множествах (`set`), так как их хэш-значения позволяют Python быстро и эффективно определять равенство объектов.

`Хэш-значение` — это уникальный набор символов, который получается в результате применения хеш-функции к некоторым данным. Если объяснить еще проще, то хэш-значение можно сравнить с отпечатком пальца для данных. Так же, как отпечаток пальца уникален для каждого человека, `хэш-значение` уникально для каждого набора данных.
Когда данные проходят через хеш-функцию, они преобразуются в короткую последовательность букв и цифр. Эта последовательность помогает быстро идентифицировать исходные данные без необходимости их полного анализа. Например, если вы хотите проверить, не изменился ли файл, вы можете сравнить его текущее хэш-значение с хэш-значением, которое было у файла ранее. Если хэши совпадают, файл остался тем же. Если нет — файл был изменен. Это очень удобно для проверки целостности данных. 

Вот примеры хэшируемых типов данных:

- **int**: Целочисленный тип данных, используемый для хранения целых чисел.
- **float**: Тип данных для чисел с плавающей точкой.
- **str**: Строковый тип данных, используемый для хранения текстовой информации.
- **tuple**: Кортежи являются неизменяемыми и могут содержать различные типы данных.
- **frozenset**: Неизменяемый вариант множества (set), который также является хэшируемым.

Пример использования хэшируемых типов данных в словаре:

```python
# Создание словаря с использованием хэшируемых типов данных в качестве ключей
my_dict = {
    1: 'один',        # int ключ
    3.14: 'пи',       # float ключ
    'name': 'Анна',   # str ключ
    (1, 2): 'кортеж'  # tuple ключ
}
```

Использование хэшируемых типов данных позволяет Python эффективно работать со словарями и множествами, обеспечивая быстрый доступ к элементам.

