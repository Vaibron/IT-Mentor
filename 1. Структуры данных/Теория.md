# Структуры данных: Stack, Queue, Deque, List, Hash table

## Стек (Stack)
- **Структура данных**, работающая по принципу "последний вошел, первый вышел" (LIFO - Last In, First Out).
- Поддерживает операции **push** (добавление элемента в вершину стека) и **pop** (удаление и возврат элемента из вершины стека).
- Также может поддерживать операцию **peek** (получение элемента из вершины стека без его удаления).
- Используется, например, при реализации функций вызова (call stack) в программировании или при обратной польской записи для вычисления арифметических выражений.

## Очередь (Queue)
- **Структура данных**, работающая по принципу "первый вошел, первый вышел" (FIFO - First In, First Out).
- Поддерживает операции **enqueue** (добавление элемента в конец очереди) и **dequeue** (удаление и возврат элемента из начала очереди).
- Также может поддерживать операцию **peek** (получение элемента из начала очереди без его удаления).
- Используется, например, для управления задачами в очереди, моделирования обслуживания запросов или управления ресурсами в параллельном программировании.

## Двусторонняя очередь (Deque)
- **Структура данных**, которая представляет собой двустороннюю очередь, то есть поддерживает добавление и удаление элементов как с начала, так и с конца.
- Поддерживает операции **appendleft** и **append** для добавления элементов в начало и конец, а также операции **popleft** и **pop** для удаления элементов с начала и конца соответственно.
- Используется, например, для реализации двусторонних алгоритмов обхода графов, работы с буферами или для реализации LRU кэшей.

## Список (List)
- Одна из базовых **структур данных**, представляющая собой упорядоченную последовательность элементов.
- Поддерживает операции добавления, удаления и доступа к элементам по индексу.
- В Python список представлен встроенным типом `list`.
- Используется для хранения и обработки коллекции элементов различных типов.

## Хеш-таблица (Hash table)
- **Структура данных**, которая реализует ассоциативный массив, связывая ключи с значениями.
- Использует функцию хеширования для преобразования ключей в индексы таблицы, что обеспечивает эффективный поиск, вставку и удаление элементов.
- В Python хеш-таблицы обычно реализованы в виде словарей (`dict`).
- Используется для реализации ассоциативных массивов, кэшей, множеств и других структур данных, где требуется быстрый доступ к данным по ключу.

# Описание алгоритмов сортировки пузырьком и сортировки вставками

## Сортировка пузырьком (Bubble Sort)
- Простой **алгоритм сортировки**, который многократно проходит по списку, сравнивая пары соседних элементов и меняя их местами, если они находятся в неправильном порядке.
- При каждом проходе самый большой элемент "всплывает" на правильное место.
- Алгоритм завершает работу, когда на очередном проходе не происходит ни одного обмена, что означает, что список уже отсортирован.
- Хотя сортировка пузырьком проста в реализации, она неэффективна для больших списков из-за своей квадратичной временной сложности.

## Сортировка вставками (Insertion Sort)
- **Алгоритм сортировки** строит отсортированную последовательность, добавляя по одному элементу из исходного списка на правильное место в уже отсортированной части списка.
- На каждом шаге алгоритм берет очередной элемент из неотсортированной части списка и вставляет его на правильное место в уже отсортированной части.
- Продолжает этот процесс до тех пор, пока все элементы не будут добавлены в отсортированную часть.
- В среднем и в худшем случае временная сложность сортировки вставками составляет $$O(n^2)$$, что делает его неэффективным для сортировки больших списков, но он может быть эффективен для небольших списков или списков, частично отсортированных. Каждый из этих алгоритмов имеет свои особенности и применения в зависимости от размера списка, его упорядоченности и других факторов.

# Алгоритмы поиска: Линейный и бинарный

## Линейный поиск (Linear Search)
- Простой **алгоритм поиска**, который последовательно проверяет каждый элемент списка или массива на наличие искомого значения.
- Начиная с первого элемента, он сравнивает каждый элемент с искомым значением до тех пор, пока не найдет совпадение или не пройдет весь список.
- Если искомое значение не найдено, алгоритм возвращает специальное значение (например, -1) или указывает на отсутствие значения.
```python
# Линейный поиск
def linear_search(arr, x):
    for i in range(len(arr)):
        if arr[i] == x:
            return i
    return -1

# Пример использования линейного поиска
arr = [3, 4, 1, 7, 5]
x = 7
index = linear_search(arr, x)
print(f"Элемент найден на позиции: {index}" if index != -1 else "Элемент не найден")
```

## Бинарный поиск (Binary Search)
- Эффективный **алгоритм поиска**, работающий только для отсортированных списков или массивов.
- Начинает поиск с середины списка и сравнивает искомое значение с элементом в середине.
- Если значение совпадает, поиск завершается.
- Если значение меньше элемента в середине, поиск продолжается в левой половине списка.
- Если значение больше элемента в середине, поиск продолжается в правой половине списка.
- Повторяет этот процесс, сокращая размер области поиска вдвое на каждом шаге, пока не будет найдено совпадение или пока область поиска не станет пустой.
- Бинарный поиск имеет временную сложность **O(\log n)**, что делает его очень эффективным для больших отсортированных списков.

Выбор между линейным и бинарным поиском зависит от различных факторов, таких как упорядоченность данных, размер списка и доступность сортировки. Если данные неотсортированы или изменяются часто, линейный поиск может быть более подходящим. Однако, если данные отсортированы и не меняются, бинарный поиск предпочтительнее из-за его высокой эффективности.



Конечно, вот примеры линейного и бинарного поиска на Python:

```python
# Линейный поиск
def linear_search(arr, x):
    for i in range(len(arr)):
        if arr[i] == x:
            return i
    return -1

# Пример использования линейного поиска
arr = [3, 4, 1, 7, 5]
x = 7
index = linear_search(arr, x)
print(f"Элемент найден на позиции: {index}" if index != -1 else "Элемент не найден")

# Бинарный поиск
def binary_search(arr, x):
    low = 0
    high = len(arr) - 1
    mid = 0

    while low <= high:
        mid = (high + low) // 2
        # Если x больше, игнорируем левую половину
        if arr[mid] < x:
            low = mid + 1
        # Если x меньше, игнорируем правую половину
        elif arr[mid] > x:
            high = mid - 1
        # Значит x присутствует в mid
        else:
            return mid
    # Если мы достигли сюда, элемента нет в массиве
    return -1

# Пример использования бинарного поиска
arr = [1, 3, 4, 5, 7]
x = 5
index = binary_search(arr, x)
print(f"Элемент найден на позиции: {index}" if index != -1 else "Элемент не найден")
```

Обратите внимание, что для корректной работы бинарного поиска массив должен быть отсортирован. Если у вас есть вопросы по этим алгоритмам или нужна помощь в других областях, пожалуйста, дайте знать!
