# Структуры данных: Stack, Queue, Deque, List, Hash table

## Стек (Stack)
- **Структура данных**, работающая по принципу "последний вошел, первый вышел" (LIFO - Last In, First Out).
- Поддерживает операции **push** (добавление элемента в вершину стека) и **pop** (удаление и возврат элемента из вершины стека).
- Также может поддерживать операцию **peek** (получение элемента из вершины стека без его удаления).
- Используется, например, при реализации функций вызова (call stack) в программировании или при обратной польской записи для вычисления арифметических выражений.

## Очередь (Queue)
- **Структура данных**, работающая по принципу "первый вошел, первый вышел" (FIFO - First In, First Out).
- Поддерживает операции **enqueue** (добавление элемента в конец очереди) и **dequeue** (удаление и возврат элемента из начала очереди).
- Также может поддерживать операцию **peek** (получение элемента из начала очереди без его удаления).
- Используется, например, для управления задачами в очереди, моделирования обслуживания запросов или управления ресурсами в параллельном программировании.

## Двусторонняя очередь (Deque)
- **Структура данных**, которая представляет собой двустороннюю очередь, то есть поддерживает добавление и удаление элементов как с начала, так и с конца.
- Поддерживает операции **appendleft** и **append** для добавления элементов в начало и конец, а также операции **popleft** и **pop** для удаления элементов с начала и конца соответственно.
- Используется, например, для реализации двусторонних алгоритмов обхода графов, работы с буферами или для реализации LRU кэшей.

## Список (List)
- Одна из базовых **структур данных**, представляющая собой упорядоченную последовательность элементов.
- Поддерживает операции добавления, удаления и доступа к элементам по индексу.
- В Python список представлен встроенным типом `list`.
- Используется для хранения и обработки коллекции элементов различных типов.

## Хеш-таблица (Hash table)
- **Структура данных**, которая реализует ассоциативный массив, связывая ключи с значениями.
- Использует функцию хеширования для преобразования ключей в индексы таблицы, что обеспечивает эффективный поиск, вставку и удаление элементов.
- В Python хеш-таблицы обычно реализованы в виде словарей (`dict`).
- Используется для реализации ассоциативных массивов, кэшей, множеств и других структур данных, где требуется быстрый доступ к данным по ключу.

# Описание алгоритмов сортировки пузырьком и сортировки вставками

## Сортировка пузырьком (Bubble Sort)
- Простой **алгоритм сортировки**, который многократно проходит по списку, сравнивая пары соседних элементов и меняя их местами, если они находятся в неправильном порядке.
- При каждом проходе самый большой элемент "всплывает" на правильное место.
- Алгоритм завершает работу, когда на очередном проходе не происходит ни одного обмена, что означает, что список уже отсортирован.
- Хотя сортировка пузырьком проста в реализации, она неэффективна для больших списков из-за своей квадратичной временной сложности.

## Сортировка вставками (Insertion Sort)
- **Алгоритм сортировки** строит отсортированную последовательность, добавляя по одному элементу из исходного списка на правильное место в уже отсортированной части списка.
- На каждом шаге алгоритм берет очередной элемент из неотсортированной части списка и вставляет его на правильное место в уже отсортированной части.
- Продолжает этот процесс до тех пор, пока все элементы не будут добавлены в отсортированную часть.
- В среднем и в худшем случае временная сложность сортировки вставками составляет $$O(n^2)$$, что делает его неэффективным для сортировки больших списков, но он может быть эффективен для небольших списков или списков, частично отсортированных. Каждый из этих алгоритмов имеет свои особенности и применения в зависимости от размера списка, его упорядоченности и других факторов.

# Алгоритмы поиска: Линейный и бинарный

## Линейный поиск (Linear Search)
- Простой **алгоритм поиска**, который последовательно проверяет каждый элемент списка или массива на наличие искомого значения.
- Начиная с первого элемента, он сравнивает каждый элемент с искомым значением до тех пор, пока не найдет совпадение или не пройдет весь список.
- Если искомое значение не найдено, алгоритм возвращает специальное значение (например, -1) или указывает на отсутствие значения.

## Бинарный поиск (Binary Search)
- Эффективный **алгоритм поиска**, работающий только для отсортированных списков или массивов.
- Начинает поиск с середины списка и сравнивает искомое значение с элементом в середине.
- Если значение совпадает, поиск завершается.
- Если значение меньше элемента в середине, поиск продолжается в левой половине списка.
- Если значение больше элемента в середине, поиск продолжается в правой половине списка.
- Повторяет этот процесс, сокращая размер области поиска вдвое на каждом шаге, пока не будет найдено совпадение или пока область поиска не станет пустой.
- Бинарный поиск имеет временную сложность $$O(\log n)$$, что делает его очень эффективным для больших отсортированных списков.

Выбор между линейным и бинарным поиском зависит от различных факторов, таких как упорядоченность данных, размер списка и доступность сортировки. Если данные неотсортированы или изменяются часто, линейный поиск может быть более подходящим. Однако, если данные отсортированы и не меняются, бинарный поиск предпочтительнее из-за его высокой эффективности.
