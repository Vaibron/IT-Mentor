# Структуры данных: Stack, Queue, Deque, List, Hash table

## Стек (Stack)
- **Структура данных**, работающая по принципу "последний вошел, первый вышел" (LIFO - Last In, First Out).
- Поддерживает операции **push** (добавление элемента в вершину стека) и **pop** (удаление и возврат элемента из вершины стека).
- Также может поддерживать операцию **peek** (получение элемента из вершины стека без его удаления).
- Используется, например, при реализации функций вызова (call stack) в программировании или при обратной польской записи для вычисления арифметических выражений.

## Очередь (Queue)
- **Структура данных**, работающая по принципу "первый вошел, первый вышел" (FIFO - First In, First Out).
- Поддерживает операции **enqueue** (добавление элемента в конец очереди) и **dequeue** (удаление и возврат элемента из начала очереди).
- Также может поддерживать операцию **peek** (получение элемента из начала очереди без его удаления).
- Используется, например, для управления задачами в очереди, моделирования обслуживания запросов или управления ресурсами в параллельном программировании.

## Двусторонняя очередь (Deque)
- **Структура данных**, которая представляет собой двустороннюю очередь, то есть поддерживает добавление и удаление элементов как с начала, так и с конца.
- Поддерживает операции **appendleft** и **append** для добавления элементов в начало и конец, а также операции **popleft** и **pop** для удаления элементов с начала и конца соответственно.
- Используется, например, для реализации двусторонних алгоритмов обхода графов, работы с буферами или для реализации LRU кэшей.

## Список (List)
- Одна из базовых **структур данных**, представляющая собой упорядоченную последовательность элементов.
- Поддерживает операции добавления, удаления и доступа к элементам по индексу.
- В Python список представлен встроенным типом `list`.
- Используется для хранения и обработки коллекции элементов различных типов.

## Хеш-таблица (Hash table)
- **Структура данных**, которая реализует ассоциативный массив, связывая ключи с значениями.
- Использует функцию хеширования для преобразования ключей в индексы таблицы, что обеспечивает эффективный поиск, вставку и удаление элементов.
- В Python хеш-таблицы обычно реализованы в виде словарей (`dict`).
- Используется для реализации ассоциативных массивов, кэшей, множеств и других структур данных, где требуется быстрый доступ к данным по ключу.

# Алгоритмы сортировки: Пузырьком и вставками

## Сортировка пузырьком (Bubble Sort)
- Простой **алгоритм сортировки**, который многократно проходит по списку, сравнивая пары соседних элементов и меняя их местами, если они находятся в неправильном порядке.
- При каждом проходе самый большой элемент "всплывает" на правильное место.
- Алгоритм завершает работу, когда на очередном проходе не происходит ни одного обмена, что означает, что список уже отсортирован.
- Хотя сортировка пузырьком проста в реализации, она неэффективна для больших списков из-за своей квадратичной временной сложности.
```python
# Сортировка пузырьком
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]

# Пример использования сортировки пузырьком
arr = [64, 34, 25, 12, 22, 11, 90]
bubble_sort(arr)
print("Отсортированный массив:", arr)
```
## Сортировка вставками (Insertion Sort)
- **Алгоритм сортировки** строит отсортированную последовательность, добавляя по одному элементу из исходного списка на правильное место в уже отсортированной части списка.
- На каждом шаге алгоритм берет очередной элемент из неотсортированной части списка и вставляет его на правильное место в уже отсортированной части.
- Продолжает этот процесс до тех пор, пока все элементы не будут добавлены в отсортированную часть.
- В среднем и в худшем случае временная сложность сортировки вставками составляет $$O(n^2)$$ что делает его неэффективным для сортировки больших списков, но он может быть эффективен для небольших списков или списков, частично отсортированных. Каждый из этих алгоритмов имеет свои особенности и применения в зависимости от размера списка, его упорядоченности и других факторов.
```python
# Сортировка вставками
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i-1
        while j >=0 and key < arr[j]:
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = key

# Пример использования сортировки вставками
arr = [12, 11, 13, 5, 6]
insertion_sort(arr)
print("Отсортированный массив:", arr)
```

# Алгоритмы поиска: Линейный и бинарный

## Линейный поиск (Linear Search)
- Простой **алгоритм поиска**, который последовательно проверяет каждый элемент списка или массива на наличие искомого значения.
- Начиная с первого элемента, он сравнивает каждый элемент с искомым значением до тех пор, пока не найдет совпадение или не пройдет весь список.
- Если искомое значение не найдено, алгоритм возвращает специальное значение (например, -1) или указывает на отсутствие значения.
```python
# Линейный поиск
def linear_search(arr, x):
    for i in range(len(arr)):
        if arr[i] == x:
            return i
    return -1

# Пример использования линейного поиска
arr = [3, 4, 1, 7, 5]
x = 7
index = linear_search(arr, x)
print(f"Элемент найден на позиции: {index}" if index != -1 else "Элемент не найден")
```

## Бинарный поиск (Binary Search)
- Эффективный **алгоритм поиска**, работающий только для отсортированных списков или массивов.
- Начинает поиск с середины списка и сравнивает искомое значение с элементом в середине.
- Если значение совпадает, поиск завершается.
- Если значение меньше элемента в середине, поиск продолжается в левой половине списка.
- Если значение больше элемента в середине, поиск продолжается в правой половине списка.
- Повторяет этот процесс, сокращая размер области поиска вдвое на каждом шаге, пока не будет найдено совпадение или пока область поиска не станет пустой.
- Бинарный поиск имеет временную сложность $$O(\log n)$$ что делает его очень эффективным для больших отсортированных списков.
```python
# Бинарный поиск
def binary_search(arr, x):
    low = 0
    high = len(arr) - 1
    mid = 0

    while low <= high:
        mid = (high + low) // 2
        # Если x больше, игнорируем левую половину
        if arr[mid] < x:
            low = mid + 1
        # Если x меньше, игнорируем правую половину
        elif arr[mid] > x:
            high = mid - 1
        # Значит x присутствует в mid
        else:
            return mid
    # Если мы достигли сюда, элемента нет в массиве
    return -1

# Пример использования бинарного поиска
arr = [1, 3, 4, 5, 7]
x = 5
index = binary_search(arr, x)
print(f"Элемент найден на позиции: {index}" if index != -1 else "Элемент не найден")
```
Выбор между линейным и бинарным поиском зависит от различных факторов, таких как упорядоченность данных, размер списка и доступность сортировки. Если данные неотсортированы или изменяются часто, линейный поиск может быть более подходящим. Однако, если данные отсортированы и не меняются, бинарный поиск предпочтительнее из-за его высокой эффективности.

# Big O Notation: Сложность Операций Чтение/Запись

## Структуры данных

### Стек (Stack)
- Чтение или запись n-ного элемента из стека имеет сложность **O(n)**.
- Стек - это структура данных Last-In-First-Out (LIFO), где доступ к элементам осуществляется только с одного конца.

### Очередь (Queue)
- Чтение или запись n-ного элемента из очереди имеет сложность **O(n)**.
- Очередь - это структура данных First-In-First-Out (FIFO), где доступ к элементам осуществляется с разных концов.

### Дек (Deque)
- Чтение или запись n-ного элемента из дека имеет сложность **O(n)**.
- Дек поддерживает операции добавления и удаления элементов с обоих концов.

### Список (List)
- Для связанных списков чтение или запись n-ного элемента имеет сложность **O(n)**.
- Для списков на основе массивов доступ к элементу по индексу может иметь сложность **O(1)**.

### Хэш-таблица (Hash table)
- В среднем случае, сложность операции чтения или записи элемента в хэш-таблице **O(1)**.
- В худшем случае, при коллизиях, сложность может быть **O(n)**.

## Типы данных

### str (строка)
- Строки используются для хранения текстовой информации.

### bytes (байт)
- Представляет последовательность байтов, используемых для работы с бинарными данными.

### bytearray (массив байтов)
- Изменяемая последовательность байтов.

### int (целое число)
- Используется для хранения целых чисел.

### float (вещественное число)
- Представляет числа с плавающей запятой.

### bool (логическое значение)
- Используется для хранения логических значений True или False.

### dict (словарь)
- Хранит коллекцию пар ключ-значение.

### list (список)
- Упорядоченная изменяемая коллекция элементов.

### tuple (кортеж)
- Упорядоченная неизменяемая коллекция элементов.

### set (множество)
- Неупорядоченная коллекция уникальных элементов.

## Big O для операций чтение/запись

### dict (словарь)
- Чтение (по ключу): **O(1)**
- Запись (по ключу): **O(1)**
- Удаление (по ключу): **O(1)**

### list (список)
- Чтение (по индексу): **O(1)**
- Запись (по индексу): **O(1)**
- Вставка/Удаление: **O(n)**

### tuple (кортеж)
- Чтение (по индексу): **O(1)**
- Кортежи не поддерживают операции вставки и удаления.

### set (множество)
- Чтение (по значению): **O(1)**
- Вставка/Удаление: **O(1)** в среднем

## Comprehensions

### List Comprehension
- Создание списка квадратов чисел: `[x**2 for x in range(10)]`
- Создание списка четных чисел: `[x for x in range(10) if x % 2 == 0]`

### Dict Comprehension
- Создание словаря с квадратами чисел: `{x: x**2 for x in range(10)}`

### Set Comprehension
- Создание множества квадратов чисел: `{x**2 for x in range(10)}`

## Изменяемые и Неизменяемые Типы Данных

### Неизменяемые
- `int`, `float`, `str`, `tuple`

### Изменяемые
- `list`, `dict`, `set`

## Хэшируемые Типы Данных

Хэшируемые (`hashable`) типы данных в Python - это типы данных, которые могут быть использованы в качестве ключей в словарях (`dict`) или элементов множеств (`set`). Они должны иметь хэш-значение (`хеш`), которое остается неизменным в течение их жизни. Когда объект хэшируем, он может быть быстро найден в словарях или множествах, что делает их эффективными для использования в качестве ключей. Вот некоторые типы данных, которые являются хэшируемыми в Python:

1. Неизменяемые типы данных: 
- `int` (целые числа)
- `float` (вещественные числа)
- `str` (строки)
- `tuple` (кортежи)

2. Некоторые изменяемые типы данных, если они не содержат изменяемых объектов: `frozenset` (неизменяемые множества)

3. Пользовательские классы, если они определяют методы hash() и eq(), и объекты экземпляра класса не изменяются после создания.

Примеры использования хэшируемых типов данных:
```python
Хэшируемый тип данных - строка
my_dict = {'name': 'John', 'age': 30}

Хэшируемый тип данных - кортеж
my_set = {(1, 2), (3, 4), (5, 6)}

Хэшируемый пользовательский класс
class Point: def init(self, x, y): self.x = x self.y = y

def eq(self, other):
return self.x == other.x and self.y == other.y

def hash(self):
return hash((self.x, self.y))
p1 = Point(1, 2) p2 = Point(1, 2)

my_set.add(p1) my_set.add(p2)

print(my_set) # {(1, 2), (3, 4), (5, 6), Point(1, 2)}
```
Использование хэшируемых типов данных обеспечивает эффективный доступ к элементам в словарях и множествах.
