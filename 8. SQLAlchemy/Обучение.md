Путешествие в мир SQLAlchemy: от основ до продвинутых техник
Введение

SQLAlchemy — это мощная и гибкая библиотека Python, которая позволяет вам работать с реляционными базами данных (СУБД) без необходимости писать громоздкий и сложный SQL-код. SQLAlchemy предоставляет два основных набора:

1. SQLAlchemy Core: низкоуровневый подход, обеспечивающий полный контроль над SQL-запросами.

2. SQLAlchemy ORM (Object Relational Mapper): Высокоуровневый подход, который ускоряет работу с базами данных, используя объектно-ориентированную модель.

Часть 1: Основы SQLAlchemy Core

1.1. Подключение к базе данных

Импортировать create_engine из sqlalchemy:

from sqlalchemy import create_engine
Выполните подключение к базе данных с помощью create_engine и URL:

engine = create_engine('sqlite:///mydatabase.db') 
# 'sqlite:///mydatabase.db' - URL для SQLite базы данных
Вы можете использовать URL для подключения к другим базам данных:

postgresql://user:password@host:port/database (PostgreSQL)
mysql://user:password@host:port/database (MySQL)
oracle://user:password@host:port/database (Оракул)
mssql+pyodbc://user:password@host:port/database?driver=SQL+Server (SQL-сервер)
1.2. Создание таблиц

Импортируйте MetaData, Table, Column, Integer и String:
from sqlalchemy import MetaData, Table, Column, Integer, String
Создайте объект метаданных:
metadata = MetaData(engine)
Определите таблицу:
users = Table(
    'users', metadata,
    Column('id', Integer, primary_key=True),
    Column('name', String)
)
составить таблицу:
metadata.create_all()
1.3. Работа с данными

Импортируйте insert, text, и execute:
from sqlalchemy import insert, text
Добавление данных:
insert_stmt = users.insert().values(name='John Doe')
engine.execute(insert_stmt)
Reading data:
result = engine.execute(text("SELECT * FROM users"))
for row in result:
    print(row)
1.4. Связи между таблицами

Импортируйте ForeignKey:
from sqlalchemy import ForeignKey
Определите таблицу orders по связи users:
orders = Table(
    'orders', metadata,
    Column('id', Integer, primary_key=True),
    Column('user_id', Integer, ForeignKey('users.id'))
)
составим таблицу orders:
metadata.create_all()
1,5. Преимущества и недостатки SQLAlchemy Core

Преимущества:
Полный контроль над SQL-запросами.
Гибкость и мощь для работы со встроенными запросами.
Высокая производительность для защитных запросов.
Недостатки:
Требует больше кода и знаний SQL.
Менее читабельный код по сравнению с ORM.
Часть 2: SQLAlchemy ORM (объектно-реляционный картограф)

2.1. Создание моделей

Импортируйте declarative_base и relationship:
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
Создайте модели базового класса:
Base = declarative_base()
Определите модель User:
class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String)
    orders = relationship("Order", back_populates="user")
Определите модель Order:
class Order(Base):
    __tablename__ = 'orders'
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('users.id'))
    user = relationship("User", back_populates="orders")
2.2. Создание таблиц (ORM)

составить таблицы:
Base.metadata.create_all(engine)
2.3. Работа с данными (ORM)

Импортируйте sessionmaker:
from sqlalchemy.orm import sessionmaker
создать фабрику сессий:
Session = sessionmaker(bind=engine)
session = Session()
Добавление данных:
user = User(name='John Doe')
session.add(user)
session.commit()
Reading data:
users = session.query(User).all()
for user in users:
    print(user.name)
Запросы:
orders = session.query(Order).filter_by(user_id=1).all()
for order in orders:
    print(order.id, order.user.name)
2.4. Преимущества и недостатки SQLAlchemy ORM

Преимущества:
Упрощает работу с данными, используя объекты Python.
Более читаемый код по сравнению с Core.
Удобен для быстрого прототипирования и работы с объектно-ориентированным кодом.
Недостатки:
Меньшая гибкость по сравнению с Core.
Может быть менее производительным для сложных запросов.
Часть 3: Дополнительные возможности

3.1.Transactions

Использование with session.begin()::
with session.begin():
    user = User(name='Jane Doe')
    session.add(user)
    order = Order(user_id=user.id)
    session.add(order)
3.2. Каскадные операции

Использование cascade="all, delete-orphan" в relationship:
orders = relationship("Order", back_populates="user", cascade="all, delete-orphan")
3.3. Пользовательские типы данных

Создание чистого типа данных:
from sqlalchemy import TypeDecorator, String

class MyCustomType(TypeDecorator):
    impl = String

    def process_bind_param(self, value, dialect):
        # Преобразование значения перед сохранением в базу данных
        return value.upper()

    def process_result_value(self, value, dialect):
        # Преобразование значения после извлечения из базы данных
        return value.lower()
3.4.Сигналы

Использование event.listen для регистрации событий обработчиков:
from sqlalchemy import event

@event.listens_for(User, 'before_insert')
def before_insert_handler(mapper, connection, target):
    # Делайте что-нибудь перед вставкой объекта User
    print('Before insert:', target.name)
Часть 4: Выбор между Core и ORM

Использовать ядро:
Если вам нужна полная гибкость и контроль над SQL-запросами.
Если вам нужна высокая производительность для защитных запросов.
Используйте ORM:
Если вам нужна простота и возможность работать с данными.
Если вам нужно быстро прототипировать приложение.
Если вы работаете с объектно-ориентированным кодом.
Дополнительные ресурсы:

Официальная документация SQLAlchemy: https://docs.sqlalchemy.org/en/14/
Примеры: https://github.com/sqlalchemy/examples
Курсы и учебники: https://www.youtube.com/results?search_query=sqlalchemy+tutorial .
Успехов в изучении SQLAlchemy!
